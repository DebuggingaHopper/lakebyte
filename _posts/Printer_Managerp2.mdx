---
date: '2025-01-02'
thumbnail: /assets/getting-started.jpg
title: Creating a printer troubleshooter Part 2 - Changing a Printer Ports IP
description: Discussing Part 2 of the creation of software that troubleshoots a printer for niche issues
---

<h1 align="center">Introduction</h1>

If your are reading part 2 then hopefully you have read part 1 of this project, if not well then here's a refresher:

Imagine getting over 20 calls in a month about a printer giving a problem, the issues always tend to be the same:
    - The printer queue is jammed
    - The IP of the printer changed so the port needs to be reconfigured

Through a C# .Net Application that utilizes two libraries [Processes](https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.process?view=net-9.0) and [prnport](https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/prnport) this issue was able to be removed. Allowing the client to just continue with their day without needing to make a call, no news is good news (most of the time).

In part 1 we created the main foundation of the program consisting of three classes: Execute, userPrinter, and finally the program.cs that has the main method of this program.


<h2 align="center">Part 2 of The Printer Troubleshooter</h2>

In this article we will detail the main components that create the next version of the printer troubleshooter:
- userPrinter class - this class will have various methods added to ensure we can change the IP set in the port for this printer. In this class, we will be using prnport
- Execute - will have new information added to the Execute class constructor, alongside a new line in the ExecuteMain method.



<h3 align="center">Background Info</h3>

Before even going forward, since we cleared the printer queue, what seems to be the main issue that this second version will address:

The issue is the IP of the printer changing, this can be very obnoxious as the HelpDesk team would need to remote into the device, and with administrator privilege change the IP that the port of this printer is pointing to.



<h3 align="center">The Config</h3>

Before diving into the code, the config file mentioned in the previous article will need to be revised to include the following:

- The printer hostname: This is the hostname that the printer was configured to have
- the Port Name: This is belonging to the port that the printer communicates to

The config file would look like the following:

``` XML
<?xml version="1.0" encoding="utf-8"?>
<Configuration>
	<startup>
		<supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7"/>
	</startup>
	<appSettings>
		<add key="PrinterName" value="PDFPrinter"/>
        <add key="PortName" value="LAN_TST12"/>
        <add key="HostName" value="TST_PRT_24"/>
	</appSettings>
</Configuration>
```

Now let's jump into the code.

<h3 align="center">How to communicate with the Port?</h3>

So we want to communicate with the printer port, well hold on there are multiple questions:
1. How do we get the new IP of the printer in the first place?
2. How do we have the port of the printer have this new IP?


So let's start with the following how exactly do we get the new IP of the printer?

Well thankfully there is a way, to see when we ping the hostname of a device we tend to get the IP returned to us, but wait that means we need the hostname. Thank goodness we made that change in the config file.


So now our userPrinter class will look like the following:
```c#
internal class userPrinter
    {
        public string Name { get;}
        public string hostName { get;}
        internal userPrinter()
        {
            Name = ConfigurationManager.AppSettings["PrinterName"];
            hostName = ConfigurationManager.AppSettings["HostName"];
        }
```

Now what we want to do is get an IP Address, well thankfully there is System.Net which has an IPHostEntry object that lets us do the following:
```c#
       public IPHostEntry ParseIPAddress()
        {
            IPHostEntry ipHE = null;
            IPAddress addr;
            if (IPAddress.TryParse(this.hostName, out addr))
            {
                ipHE = new IPHostEntry();
                ipHE.AddressList = new IPAddress[1];
                ipHE.AddressList[0] = addr;
            }
            return ipHE;
        }
```


Cool we made an object referencing the hostname and within this object, there is a list of 1 item that is the returned IP
```
      public void changeIP()
        {


            IPHostEntry hostEntry = this.ParseIPAddress();
            if (hostEntry.AddressList.Length > 0)
            {
                var ip = hostEntry.AddressList[0];
                this.ExecutePrinterManagementCommand(ip);
            }
        }
```

So now that we have the IP, let's change the ports IP it's referencing, wait but how in the world do we achieve that?


<h4 align="center">So what's prnport</h4>

Windows has some nice command line tools that help with printer management, so let's use one of these tools with the IP we got from our code.

PrnPort is something I found fascinating the first time I saw it, as this is something that can edit, create, delete, and just play with the TCP/IP ports of a printer.

After reading the documentation (which honestly was very simple and easy to get used to after a bit) I was able to draft the following.

```
prnport -t -r portName -h newIP -n 9100
```

All we are doing is revising the port with the specific name to the specific IP address and ensuring it has the right port number.

Now we can test this command on any computer however every time we need to remember that not only do we use cscript but the directory we have to be in is **%WINdir%\System32\printing_Admin_Scripts\en-US\prnport**

So now we are using a command line tool in a specific directory, well then given we did something similar looks like now we will be combining the processes library and prnport in one function:

```
       public void ExecutePrinterManagementCommand(IPAddress IpAddress)
        {
            string newIP = IpAddress.ToString();
            var processInfo = new ProcessStartInfo("cmd.exe", "/c " + "cscript prnport -t -r" + " " + "\"" + this.portName + "\"" + " " + "-h" + newIP + " " + "-n 9100")
            {
                CreateNoWindow = true,
                WorkingDirectory = @"%WINdir%\System32\printing_Admin_Scripts\en-US",
                WindowStyle = ProcessWindowStyle.Hidden,
                UseShellExecute = false,
                RedirectStandardError = true,
                RedirectStandardOutput = true

            };
            var process = Process.Start(processInfo);
            process.BeginOutputReadLine();
            process.BeginErrorReadLine();
            process.WaitForExit();
            process.Close();
        }
```

Now this may seem like a lot but remember what we got is an IPAddress type, but we want a string in our cmd command. So let's just make that IP into a string, and plug it into our string calling the prnport command with the given parameters.

But wait how do we know we are in the right directory cause if I run this anywhere else it won't know what prnport is. Well, thankfully the processStartInfo object has a workingDirectory parameter, allowing us to quickly set it to what we need.

But wait before we finish let's see what another way to revise our way to get the IP address from a hostname!

<h4 align="center">improving how to get IP from hostname</h4>

So we have one way to get the IP address from a hostname, but it's in two different methods. There should be a different way to do it right?

Not only that what if we get IPv6, this method seems inefficient doesn't it, well what if we can condense it even more:

```
public void changeIP(){
    IPAddress outIpAddress;
    if(IPAddress.TryParse(this.hostName,out outIpAddress) == true){
        IPAddress address = System.Net.Dns.GetHostEntry(this.hostName).AddressList.First(addr => addr.AddressFamily == System.Net.Sockets.AddressFaamily.InterNetwork);
        this.ExecutePrinterManagementCommand(address);
    }
}
```

Would you look at that not only did we just condense two methods into one, but we also ensured the IP address we get is IPv4, and before even trying that we confirmed if we got any IP from the hostname at all.

So perfect we ensured that we could change the IP of the port and found an easy way to resolve the hostname. But wait this is still an experimental feature, how can I toggle if I want to use it or not?


<h3 align="center">How to toggle this feature?</h3>

Well we did all this work but I don't want my team to use this feature yet, how do we stop them per se?

Well here comes the fun part, first we edited the config to have the following:
```xml<?xml version="1.0" encoding="utf-8"?>
<Configuration>
	<startup>
		<supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7"/>
	</startup>
	<appSettings>
		<add key="PrinterName" value="PDFPrinter"/>
        <add key="PortName" value="LAN_TST12"/>
        <add key="HostName" value="TST_PRT_24"/>
        <add key="EnablePortFunc" value="N"/>
	</appSettings>
</Configuration>
```
So what does this do, well its the flag our code will check, as now we will go the Execute.cs class we made in the last article and do the following to the constructor:

```c#
        public bool enableFeatures { get;}
        internal Execute()
        {
            resourceName = "LoccioniQueueManager.ClearQ.bat";
            tempPath = System.IO.Path.GetTempPath() + "\\LQM.bat";
            enableFeatures = ConfigurationManager.AppSettings["EnablePortFunc"] == "Y" ? true : false;
        }
```

A simple boolean flag has now been made and in our execute main method all we need to do is the following:
```c#
       public void ExecuteMain(userPrinter currPrinter)
        {
            initiateSplash();
            if (this.enableFeatures)
            {
                currPrinter.changeIP();
            }
            var assembly = Assembly.GetExecutingAssembly();
            using (Stream input = assembly.GetManifestResourceStream(resourceName))
            using (Stream output = File.Create(this.tempPath))
            {
                CopyStream(input, output);
            }
            ExecuteCommand(currPrinter.Name);
            File.Delete(this.tempPath);
        }

```

The only change is that we check this parameter in the execute class, and if true we immediately change the IP as this troubleshooter is meant to fix everything in one go.

So perfect we have everything for our next version of the troubleshooter!

<h2 align="center">Conclusion</h2>

Congrats now we have everything set for this new feature, but wait as much as we have covered the development of this feature, we never got to the installer. Well, that's part 3 of this project as I have a story about that.










